2024/10/24 15:31:27 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:31:27 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:28 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:31:28 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:29 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:31:29 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:30 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:31:30 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:30 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:31:30 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:31 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:31:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:32 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:31:32 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:32 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:31:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:33 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:31:33 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:31:33 网站无法访问
2024/10/24 15:33:05 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:05 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:06 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:06 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:06 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:06 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:07 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:07 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:07 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:07 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:07 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:07 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:07 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:08 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:08 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:08 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:08 网站无法访问
2024/10/24 15:33:09 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:09 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:09 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:09 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:10 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:10 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:10 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:10 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:10 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:10 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:10 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:11 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:11 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:11 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:11 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:11 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:11 网站无法访问
2024/10/24 15:33:12 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:12 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:12 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:12 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:13 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:13 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:13 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:13 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:13 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:13 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:13 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:14 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:14 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:14 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:14 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:14 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:14 网站无法访问
2024/10/24 15:33:15 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:15 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:15 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:15 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:15 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:15 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:16 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:16 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:16 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:16 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:17 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:17 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:17 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:18 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:18 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:18 网站无法访问
2024/10/24 15:33:18 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:18 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:19 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:19 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:19 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:19 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:19 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:19 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:19 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:19 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:20 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:20 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:20 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:21 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:21 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:21 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:21 网站无法访问
2024/10/24 15:33:21 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:21 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:22 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:22 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:23 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:23 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:23 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:23 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:23 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:23 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:23 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:24 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:24 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:24 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:24 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:24 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:24 网站无法访问
2024/10/24 15:33:25 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:25 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:25 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:25 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:25 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:25 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:26 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:26 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:26 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:26 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:26 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:26 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:26 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:27 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:27 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:27 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:27 网站无法访问
2024/10/24 15:33:28 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:28 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:28 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:28 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:29 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:30 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:30 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:30 网站无法访问
2024/10/24 15:33:30 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:30 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:31 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:31 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:31 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:31 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:31 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:31 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:31 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:31 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:32 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:32 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:32 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:33 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:33 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:33 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:33 网站无法访问
2024/10/24 15:33:33 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:34 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:34 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:34 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:34 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:34 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:34 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:34 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:34 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:35 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:35 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:35 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:35 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:35 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:35 网站无法访问
2024/10/24 15:33:36 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:36 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:36 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:36 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:36 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:36 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:36 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:36 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:37 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:37 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:37 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:37 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:38 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:38 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:38 网站无法访问
2024/10/24 15:33:38 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:38 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:38 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:39 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:39 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:39 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:39 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:39 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:39 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:40 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:40 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:40 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:40 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:40 网站无法访问
2024/10/24 15:33:40 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:40 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:41 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:41 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:41 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:41 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:42 网站无法访问
2024/10/24 15:33:43 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:43 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:43 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:43 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:43 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:44 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:44 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:44 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:44 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:44 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:44 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:44 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:45 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:45 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:45 网站无法访问
2024/10/24 15:33:45 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:45 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:45 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:46 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:46 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:46 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:46 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:46 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:46 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 网站无法访问
2024/10/24 15:33:47 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:47 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 网站无法访问
2024/10/24 15:33:48 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:48 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:49 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:49 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:49 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:49 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:49 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:49 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:49 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:50 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:50 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:50 网站无法访问
2024/10/24 15:33:50 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:50 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:51 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:51 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:52 网站无法访问
2024/10/24 15:33:53 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:53 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:53 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:53 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:53 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:53 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:54 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:54 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:54 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:54 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:54 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:54 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:54 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:55 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:55 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:55 网站无法访问
2024/10/24 15:33:55 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:55 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:56 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:56 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:56 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:56 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:56 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:56 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:56 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:57 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:57 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:57 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:33:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:57 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:33:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:57 网站无法访问
2024/10/24 15:33:58 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:33:58 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:58 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:33:58 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:59 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:33:59 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:59 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:33:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:59 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:33:59 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:59 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:33:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:33:59 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:33:59 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:00 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:00 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:00 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:00 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:00 网站无法访问
2024/10/24 15:34:01 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:01 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:01 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:01 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:01 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:01 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 网站无法访问
2024/10/24 15:34:02 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:02 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:03 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:03 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:03 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:03 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:03 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:04 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:04 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:04 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:04 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:04 网站无法访问
2024/10/24 15:34:04 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:04 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:05 网站无法访问
2024/10/24 15:34:05 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:05 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:06 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:06 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:06 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:06 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:06 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:06 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:06 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:07 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:07 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:07 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:07 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:07 网站无法访问
2024/10/24 15:34:08 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:08 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:08 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:08 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:08 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:09 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:09 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:09 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:09 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:09 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:09 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:09 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:10 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:10 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:10 网站无法访问
2024/10/24 15:34:10 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:10 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:10 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:11 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:11 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:11 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:11 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:11 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:11 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:12 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:12 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:12 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:12 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:12 网站无法访问
2024/10/24 15:34:12 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 网站无法访问
2024/10/24 15:34:13 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:13 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:14 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:14 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:14 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:14 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:14 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:14 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:14 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:14 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:15 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:15 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:15 网站无法访问
2024/10/24 15:34:15 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:15 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:15 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:16 网站无法访问
2024/10/24 15:34:16 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:17 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:17 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:18 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:18 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:18 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:18 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:18 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:18 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:18 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:19 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:19 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:19 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:19 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:19 网站无法访问
2024/10/24 15:34:19 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:19 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:19 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:20 网站无法访问
2024/10/24 15:34:21 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:21 网站无法访问
2024/10/24 15:34:22 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 网站无法访问
2024/10/24 15:34:22 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:22 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 网站无法访问
2024/10/24 15:34:23 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:23 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:23 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:24 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:24 网站无法访问
2024/10/24 15:34:25 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:25 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:25 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:25 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:26 网站无法访问
2024/10/24 15:34:27 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:27 网站无法访问
2024/10/24 15:34:27 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:28 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:28 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:28 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:28 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:28 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:28 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:28 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:29 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:29 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:29 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:29 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:29 网站无法访问
2024/10/24 15:34:29 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:29 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:29 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:30 网站无法访问
2024/10/24 15:34:31 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:31 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:31 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:31 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:31 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 网站无法访问
2024/10/24 15:34:32 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:32 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:33 网站无法访问
2024/10/24 15:34:33 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:34 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:34 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:34 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:34 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:34 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:34 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:34 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:34 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 网站无法访问
2024/10/24 15:34:35 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:35 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:36 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:36 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:36 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:36 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:36 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:37 网站无法访问
2024/10/24 15:34:37 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:37 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:37 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:38 网站无法访问
2024/10/24 15:34:38 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:39 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:39 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:39 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:39 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:39 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:39 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:39 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:39 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:40 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:40 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:40 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:40 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:40 网站无法访问
2024/10/24 15:34:40 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:40 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:41 网站无法访问
2024/10/24 15:34:42 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:42 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:42 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:42 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:42 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:43 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:43 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:43 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:43 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:43 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:43 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:43 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:44 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:44 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:44 网站无法访问
2024/10/24 15:34:45 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:45 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:45 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:45 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:45 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:34:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:45 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:34:45 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:45 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:34:45 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:46 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:34:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:46 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:34:46 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:46 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:34:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:46 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:34:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:46 网站无法访问
2024/10/24 15:34:46 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:34:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:34:47 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:34:47 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:51 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:35:51 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:52 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:35:52 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:52 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:35:52 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:53 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:35:53 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:53 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:35:53 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:53 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:35:53 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:54 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:35:54 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:54 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:35:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:54 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:35:54 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:35:54 网站无法访问
2024/10/24 15:37:15 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:37:15 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:16 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:37:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:16 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:37:16 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:17 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:37:17 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:17 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:37:17 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:17 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:37:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:17 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:37:17 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:18 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:37:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:18 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:37:18 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:37:18 网站无法访问
2024/10/24 15:40:50 请求html错误 https://www.hm01.lol/albums-index-cate-20.html
2024/10/24 15:40:50 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:51 请求html错误 https://www.hm02.lol/albums-index-cate-20.html
2024/10/24 15:40:51 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:51 请求html错误 https://www.hm03.lol/albums-index-cate-20.html
2024/10/24 15:40:51 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:52 请求html错误 https://www.hm04.lol/albums-index-cate-20.html
2024/10/24 15:40:52 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:52 请求html错误 https://www.hm05.lol/albums-index-cate-20.html
2024/10/24 15:40:52 System.Net.WebException: 未能解析此远程名称: 'www.hm05.lol'
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:52 请求html错误 https://www.hm06.lol/albums-index-cate-20.html
2024/10/24 15:40:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:53 请求html错误 https://www.hm07.lol/albums-index-cate-20.html
2024/10/24 15:40:53 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:53 请求html错误 https://www.hm08.lol/albums-index-cate-20.html
2024/10/24 15:40:53 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:54 请求html错误 https://www.hm09.lol/albums-index-cate-20.html
2024/10/24 15:40:54 System.Net.WebException: 基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。 ---> System.Security.Authentication.AuthenticationException: 根据验证过程，远程证书无效。
   在 System.Net.Security.SslState.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, Exception exception)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReadFrame(Byte[] buffer, Int32 readBytes, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:40:54 网站无法访问
2024/10/24 15:42:43 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:42:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:17 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:39 请求html错误 https://wn02.cc/search/?q=%E5%88%9D%E6%AC%A1%E6%B7%B1%E4%BA%A4%EF%BC%8C%E8%AB%8B%E5%A4%9A%E6%8C%87%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:39 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%9C%98%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:40 请求html错误 https://wn02.cc/search/?q=%E6%B4%9E%E6%B4%9E%E9%9B%9C%E8%B2%A8%E5%BA%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:40 请求html错误 https://wn02.cc/search/?q=%E6%95%99%E7%BE%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:41 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E5%AE%B6%E7%9A%84%E8%B4%85%E5%A9%BF%E5%A4%A7%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:41 请求html错误 https://wn02.cc/search/?q=%E6%88%80%E6%84%9B%E4%BF%A1%E4%BB%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:42 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E9%AB%94%E5%85%A7%E7%9A%84%E9%82%A3%E5%80%8B%E7%A5%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:42 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E4%BA%8B%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:45 请求html错误 https://wn02.cc/search/?q=%E8%B7%91%E5%8F%8B%E8%AE%8A%E5%B2%B3%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:45 请求html错误 https://wn02.cc/search/?q=%E7%A6%81%E9%8C%AE%E4%B9%8B%E6%85%BE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:45 请求html错误 https://wn02.cc/search/?q=%E8%90%AC%E8%83%BD%E5%B1%A5%E6%AD%B7%E8%A1%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:46 请求html错误 https://wn02.cc/search/?q=%E5%A5%B9%E7%9A%84%E5%AF%82%E5%AF%9E%E8%AA%B0%E4%BA%BA%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:46 请求html错误 https://wn02.cc/search/?q=%E7%96%AB%E6%83%85%E6%9C%9F%E9%96%93%E7%9A%84%E5%AE%B6%E6%95%99%E7%94%9F%E6%B4%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:48 请求html错误 https://wn02.cc/search/?q=%E5%A5%B3%E6%80%A7%E5%8F%8B%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:48 请求html错误 https://wn02.cc/search/index.php?q=%E5%A4%A7%E5%AD%B8%E7%94%9F%E6%B4%BB%E5%B0%B1%E5%BE%9E%E7%A4%BE%E5%9C%98%E9%96%8B%E5%A7%8B&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 15:56:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:48 请求html错误 https://wn02.cc/search/?q=%E7%A7%98%E5%AF%86%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:50 请求html错误 https://wn02.cc/search/index.php?q=%E5%82%80%E5%84%A1&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 15:56:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:54 请求html错误 https://wn02.cc/search/?q=%E7%99%A1%E6%BC%A2%E6%88%90%E7%99%AE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:54 请求html错误 https://wn02.cc/search/?q=%E5%85%B6%E5%AF%A6%E6%88%91%E5%BE%88%E5%96%9C%E6%AD%A1%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:54 请求html错误 https://wn02.cc/search/?q=%E9%87%8D%E9%80%A2%E7%9A%84%E5%88%9D%E6%88%80%E6%98%AF%E7%B9%BC%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:54 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:56 请求html错误 https://wn02.cc/search/?q=%E9%99%8C%E7%94%9F%E7%9A%84%E6%9C%AA%E5%A9%9A%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:56 请求html错误 https://wn02.cc/search/?q=%E6%85%BE%E6%B5%B7%E4%BA%A4%E9%8B%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:56 请求html错误 https://wn02.cc/search/?q=%E8%89%B2%E9%B5%B0%E8%8B%B1%E9%9B%84%E5%82%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:56 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:57 请求html错误 https://wn02.cc/search/?q=%E7%9B%A3%E7%8D%84%E5%A5%B3%E5%9B%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:57 请求html错误 https://wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E6%95%99%E6%8E%88%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:57 请求html错误 https://wn02.cc/search/?q=%E9%81%8A%E6%88%B2%E4%B8%8D%E8%83%BD%E9%80%99%E6%A8%A3%E7%8E%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:57 请求html错误 https://wn02.cc/search/?q=%E5%A4%B1%E6%86%B6%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:57 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:58 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%8D%80%E9%87%8D%E5%BB%BA%E5%8D%94%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:58 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:58 请求html错误 https://wn02.cc/search/?q=%E6%84%9B%E6%89%93%E9%81%8A%E6%88%B2%E7%9A%84%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:58 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:58 请求html错误 https://wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:58 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:59 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E7%94%A8%E5%95%AA%E6%94%AF%E4%BB%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:56:59 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E5%B1%85%E4%B8%8A%E4%B8%8B%E8%88%96&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:56:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:00 请求html错误 https://wn02.cc/search/?q=%E7%BE%8E%E9%BA%97%E6%96%B0%E4%B8%96%E7%95%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:00 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:03 请求html错误 https://wn02.cc/search/?q=%E8%B5%B0%E5%91%B3%E7%9A%84%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:03 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%A9%86%E8%87%B3%E4%B8%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:04 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E4%BA%8B%E7%89%A9%E8%AA%9E+Fantasy&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:04 请求html错误 https://wn02.cc/search/?q=%E4%B8%8D%E8%89%AF%E4%BA%8C%E7%AD%89%E5%85%B5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:04 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E5%AE%9A%E5%A4%A7%E9%98%AA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:04 请求html错误 https://wn02.cc/search/?q=%E6%B0%B4%E9%9B%BB%E5%B7%A5%E6%97%A5%E8%AA%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:05 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E7%9A%84%E9%A6%99%E5%91%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:05 请求html错误 https://wn02.cc/search/?q=%E5%A4%9C%E9%96%93%E8%A8%BA%E7%99%82%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:05 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E8%A4%B2%E8%A4%B2%E7%AD%86%E8%A8%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:05 请求html错误 https://wn02.cc/search/?q=%E6%89%8B%E5%B7%A5%E9%A3%BE%E5%93%81%E5%B7%A5%E5%BB%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:06 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%AA%B2%E5%A4%96%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:06 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E5%AD%A9%E5%AD%90%E6%89%8D%E5%81%9A%E9%81%B8%E6%93%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:07 请求html错误 https://wn02.cc/search/?q=%E6%83%A1%E5%A5%B3%E5%8B%BE%E5%8B%BE%E7%BA%8F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:08 请求html错误 https://wn02.cc/search/index.php?q=%E9%98%BF%E5%A7%A8&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 15:57:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:09 请求html错误 https://wn02.cc/search/?q=%E9%A4%8A%E7%88%B6%E7%9A%84%E5%A5%B3%E5%85%92%E5%80%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:09 请求html错误 https://wn02.cc/search/?q=%E8%A1%97%E9%A0%AD%E5%B9%B9%E6%9E%B6%E7%8E%8B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:09 请求html错误 https://wn02.cc/search/?q=%E5%BE%A9%E4%BB%87%E6%AF%8D%E5%A5%B3%E4%B8%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:09 请求html错误 https://wn02.cc/search/?q=%E5%8F%8B%E6%83%85%E8%90%AC%E7%9D%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:10 请求html错误 https://wn02.cc/search/?q=%E6%90%B6%E5%A5%B3%E5%8F%8B%E9%80%9F%E6%88%90%E7%8F%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:10 请求html错误 https://wn02.cc/search/?q=%E6%AD%A1%E8%BF%8E%E5%8A%A0%E5%85%A5%E7%B2%89%E7%B5%B2%E5%9C%98%EF%BC%81+&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:10 请求html错误 https://wn02.cc/search/?q=%E9%9D%92%E6%A2%85%E4%BB%A5%E4%B8%8A%E6%88%80%E4%BA%BA%E6%9C%AA%E6%BB%BF&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:10 请求html错误 https://wn02.cc/search/?q=%E7%91%9C%E7%8F%88%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:11 请求html错误 https://wn02.cc/search/?q=%E5%88%86%E7%B5%84%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:11 请求html错误 https://wn02.cc/search/index.php?q=%E8%89%B2%E8%BC%AA%E7%9C%BC&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 15:57:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:12 请求html错误 https://wn02.cc/search/?q=%E7%98%8B%E4%BA%86%E6%89%8D%E7%B5%90%E5%A9%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:12 请求html错误 https://wn02.cc/search/?q=%E7%82%B8%E8%A3%82%E5%90%A7%21%E5%B7%A8%E6%A3%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:12 请求html错误 https://www.wn02.cc/search/?q=%E8%AA%BF%E6%95%99%E5%A6%BB%E5%AD%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:13 请求html错误 https://www.wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:13 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9B%E4%BA%BA%E5%90%8C%E5%B1%85%E5%A4%AA%E6%93%81%E6%93%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:13 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E4%BA%BA%E6%B0%A3%E7%BE%8E%E8%A1%93%E5%AE%B6%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:13 请求html错误 https://www.wn02.cc/search/?q=%E7%A5%9E%E7%A7%98%E9%A6%99%E5%91%B3%E7%A0%94%E7%A9%B6%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:14 请求html错误 https://www.wn02.cc/search/?q=%E7%9B%B4%E6%92%AD%E4%B8%BB%E7%9A%84%E6%B5%81%E9%87%8F%E5%AF%86%E7%A2%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:14 请求html错误 https://www.wn02.cc/search/?q=%E5%82%B3%E5%AE%97%E6%8E%A5%E4%BB%A3%E5%A5%BD%E5%9B%B0%E9%9B%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:14 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E9%82%82%E9%80%85&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:14 请求html错误 https://www.wn02.cc/search/?q=%E7%86%9F%E5%A5%B3%E9%83%BD%E6%84%9B%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:15 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%8C%E7%BE%8E%E5%A6%BB%E5%AD%90%E7%9A%84%E8%83%8C%E5%8F%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:15 请求html错误 https://wn02.cc/search/?q=%E8%AE%93%E4%BA%BA%E7%81%AB%E5%A4%A7%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:15 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E6%8A%8A%E5%A5%B3%E5%85%92%E4%BA%A4%E7%B5%A6%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:16 请求html错误 https://wn02.cc/search/?q=%E6%82%A3%E5%BE%97%E6%82%A3%E5%A4%B1%E7%9A%84%E6%84%9B%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:16 请求html错误 https://wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:16 请求html错误 https://wn02.cc/search/?q=%E7%9B%B8%E8%A6%AA%E7%9B%B8%E6%84%9B%E4%B8%80%E5%AE%B6%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:16 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E7%9A%84%E6%80%A7%E7%A6%8F%E5%8A%87%E6%9C%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:17 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E8%88%87%E7%B9%BC%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:17 请求html错误 https://wn02.cc/search/?q=%E7%A9%BF%E5%85%A5VR%E6%88%90%E7%82%BA%E6%80%A7%E5%9F%9F%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:17 请求html错误 https://wn02.cc/search/?q=%E6%83%B3%E8%A6%81%E6%93%81%E6%9C%89%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:17 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:17 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E5%A3%AB%E5%85%B5%E7%9A%84%E9%9B%8C%E6%80%A7%E5%BE%81%E6%9C%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:18 请求html错误 https://www.wn02.cc/search/?q=%E5%AD%B8%E6%A0%A1%E6%AF%8D%E6%B9%AF%E9%BB%91%E7%99%BD%E4%BE%86%EF%BC%81&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:18 请求html错误 https://www.wn02.cc/search/?q=%E8%AE%93%E5%82%B2%E6%85%A2%E5%A5%B3%E5%B1%88%E6%9C%8D%E7%9A%84%E4%B8%80%E7%99%BE%E7%A8%AE%E6%96%B9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:18 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:18 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%BD%E9%81%8B%E8%A8%88%E7%A8%8B%E8%BB%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:19 请求html错误 https://www.wn02.cc/search/?q=%E7%84%A1%E6%B3%95%E5%85%8B%E5%88%B6%E7%9A%84%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:19 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:19 请求html错误 https://www.wn02.cc/search/?q=%E5%BC%B7%E5%88%B6%E5%82%AC%E7%9C%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:21 请求html错误 https://www.wn02.cc/search/?q=%E9%9F%B6%E6%81%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:21 请求html错误 https://www.wn02.cc/search/?q=%E6%8E%A0%E5%A5%AA%E8%A1%8C%E5%8B%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:21 请求html错误 https://www.wn02.cc/search/?q=%E7%99%A2%E6%A8%82%E5%A4%9A%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:22 请求html错误 https://www.wn02.cc/search/?q=%E8%B1%AA%E8%89%B2%E5%BE%A9%E4%BB%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:22 请求html错误 https://www.wn02.cc/search/?q=%E6%85%BE%E6%9C%9B%E9%81%8A%E6%88%B2%E5%AF%A6%E5%A2%83%E7%A7%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:22 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%B5%84%E5%AE%B6%E5%BA%AD%E5%A5%BD%E5%B0%B7%E5%B0%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:22 请求html错误 https://www.wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E8%A6%AA%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:23 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8B%E7%8F%AD%E5%BE%8C%E7%9A%84%E7%A7%98%E5%AF%86%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:23 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E5%BE%AE%E5%A6%99%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:23 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A6%81%E6%AC%BA%E8%B2%A0%E6%88%91%E5%A7%90%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:23 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A9%B2%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:23 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E9%97%86%E5%A8%98%E7%9A%84%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:24 请求html错误 https://www.wn02.cc/search/?q=%E6%80%A7%E9%81%8B%E5%88%AE%E5%88%AE%E6%A8%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:24 请求html错误 https://www.wn02.cc/search/?q=%E5%A3%9E%E5%A5%B3%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:24 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%80%E6%A1%BF%E9%80%B2%E6%B4%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:24 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E6%8E%A7&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:25 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E4%BA%BA%E9%BA%A5%E8%A8%88%E8%BC%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:25 请求html错误 https://www.wn02.cc/search/?q=%E9%84%B0%E5%B1%85%E8%B7%91%E8%B7%AF%E4%B8%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:25 请求html错误 https://www.wn02.cc/search/?q=%E5%86%B0%E5%B1%B1%E4%B8%BB%E7%AE%A1%E7%9A%84%E7%A7%98%E5%AF%86%E8%88%88%E8%B6%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:25 请求html错误 https://www.wn02.cc/search/?q=%E4%BC%BC%E6%9B%BE%E7%9B%B8%E8%AD%98%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:26 请求html错误 https://www.wn02.cc/search/?q=%E6%84%8F%E5%A4%96%E7%9A%84%E7%A7%81%E5%AF%86%E7%89%BD%E7%B5%86&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:26 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E5%A9%9A%E5%A7%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:26 请求html错误 https://www.wn02.cc/search/?q=%E5%BF%AB%E6%A8%82%E4%B9%8B%E7%A5%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:26 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E6%95%99%E4%BD%8F%E6%88%91%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:27 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%A8%E7%A7%80%E8%88%87%E5%8D%9E%E6%B3%B0%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:27 请求html错误 https://www.wn02.cc/search/?q=%E6%95%99%E8%A8%93%E5%91%8A%E7%99%BD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:27 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%8B%E6%89%BE%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:27 请求html错误 https://www.wn02.cc/search/?q=%E5%92%96%E5%95%A1%E5%9B%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:28 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:28 请求html错误 https://www.wn02.cc/search/?q=%E8%BF%94%E9%84%89%E5%BE%8C%E7%9A%84%E6%98%A5%E5%A4%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:28 请求html错误 https://www.wn02.cc/search/?q=%E6%AF%92%E9%85%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:28 请求html错误 https://www.wn02.cc/search/?q=%E9%81%8A%E6%A8%82%E5%9C%92%E7%94%B7%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:29 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%A6%AA%E5%AF%86%E6%8C%87%E5%B0%8E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:29 请求html错误 https://www.wn02.cc/search/?q=%E8%8A%B1%E5%AE%B9%E6%BF%95%E8%89%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:29 请求html错误 https://www.wn02.cc/search/?q=%E5%82%AC%E7%9C%A0%E6%92%A9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:29 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E7%B4%9A%E9%8A%80%E8%A1%8C%E6%A5%AD%E5%8B%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:30 请求html错误 https://www.wn02.cc/search/?q=%E8%84%AB%E5%BA%8F%E4%BA%BA%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:30 请求html错误 https://www.wn02.cc/search/?q=%E6%94%BE%E4%BB%BB%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:30 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E6%88%90%E7%82%BA%E5%A4%A7%E9%9A%BB%E4%BD%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:30 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:30 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%BB%E8%A9%A6%E4%B9%8B%E7%A5%9E%E5%AD%B8%E7%BF%92%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:31 请求html错误 https://www.wn02.cc/search/?q=%E4%BB%96%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:31 请求html错误 https://www.wn02.cc/search/?q=%E6%96%B0%E9%83%BD%E5%B8%82%E5%A4%96%E9%80%81%E5%93%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:31 请求html错误 https://www.wn02.cc/albums-index-page-6-cate-20.html
2024/10/24 15:57:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:31 请求html错误 https://www.wn02.cc/search/?q=%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%81%B7%E5%81%B7%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:32 请求html错误 https://www.wn02.cc/search/?q=%E5%AB%81%E5%85%A5%E8%B1%AA%E9%96%80%E7%9A%84%E8%80%81%E5%B8%AB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:32 请求html错误 https://www.wn02.cc/search/?q=%E7%8B%82%E7%9C%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:32 请求html错误 https://www.wn02.cc/search/?q=Set+up%21%E6%8E%92%E7%90%83%E5%B0%91%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:32 请求html错误 https://www.wn02.cc/search/?q=%E5%B2%B3%E6%AF%8D%E7%82%BA%E4%BD%95%E9%82%A3%E6%A8%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:32 请求html错误 https://www.wn02.cc/search/?q=%E5%85%84%E5%A6%B9%E7%9A%84%E7%A7%98%E5%AF%86%E6%8E%88%E8%AA%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:33 请求html错误 https://www.wn02.cc/search/?q=%E7%B3%96%E6%9E%9C%E7%88%B8%E7%88%B8%E7%9A%84%E6%90%B6%E5%A9%9A%E5%A4%A7%E4%BD%9C%E6%88%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:33 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:33 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:33 请求html错误 https://www.wn02.cc/search/?q=%E5%81%B6%E7%84%B6%E7%99%BC%E7%8F%BE%E6%88%91%E6%84%9B%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:34 请求html错误 https://www.wn02.cc/search/?q=%E5%A4%A9%E4%B8%8A%E6%8E%89%E4%B8%8B%E4%BE%86%E7%9A%84%E7%88%BD%E7%BC%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:34 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%88%BD%E7%88%BD%E5%8D%87%E7%B4%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:34 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E5%90%8C%E5%AD%B8%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:35 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%B9%E6%89%8D%E4%B8%8D%E6%98%AF%E6%88%91%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:35 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%9A%84%E5%95%A6%E5%95%A6%E9%9A%8A%E7%BE%8E%E7%9C%89&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:35 请求html错误 https://www.wn02.cc/search/?q=%E5%81%8F%E5%81%8F%E6%85%BE%E5%88%B0%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:35 请求html错误 https://www.wn02.cc/search/?q=%E5%B9%BC%E9%BD%92%E5%B0%8F%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:35 请求html错误 https://www.wn02.cc/search/?q=%E7%94%9C%E8%9C%9C%E7%9A%84%E5%81%87%E6%9C%9F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:57:36 请求html错误 https://www.wn02.cc/search/?q=%E5%91%BD%E9%81%8B%3A%E8%B2%9E%E6%BD%94%E6%85%BE%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:57:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:59:52 请求html错误 https://www.wn02.cc/search/?q=%E5%91%BD%E9%81%8B%3A%E8%B2%9E%E6%BD%94%E6%85%BE%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:59:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:59:52 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E5%88%B0%E9%81%8E%E5%8E%BB%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:59:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:59:53 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:59:53 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:59:59 请求html错误 https://wn02.cc/search/?q=%E5%88%9D%E6%AC%A1%E6%B7%B1%E4%BA%A4%EF%BC%8C%E8%AB%8B%E5%A4%9A%E6%8C%87%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:59:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 15:59:59 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%9C%98%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 15:59:59 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:00 请求html错误 https://wn02.cc/search/?q=%E6%B4%9E%E6%B4%9E%E9%9B%9C%E8%B2%A8%E5%BA%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:00 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:00 请求html错误 https://wn02.cc/search/?q=%E6%95%99%E7%BE%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:00 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:00 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E5%AE%B6%E7%9A%84%E8%B4%85%E5%A9%BF%E5%A4%A7%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:00 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:01 请求html错误 https://wn02.cc/search/?q=%E6%88%80%E6%84%9B%E4%BF%A1%E4%BB%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:01 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:01 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E9%AB%94%E5%85%A7%E7%9A%84%E9%82%A3%E5%80%8B%E7%A5%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:01 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:01 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E4%BA%8B%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:01 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:02 请求html错误 https://wn02.cc/search/?q=%E8%B7%91%E5%8F%8B%E8%AE%8A%E5%B2%B3%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:02 请求html错误 https://wn02.cc/search/?q=%E7%A6%81%E9%8C%AE%E4%B9%8B%E6%85%BE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:02 请求html错误 https://wn02.cc/search/?q=%E8%90%AC%E8%83%BD%E5%B1%A5%E6%AD%B7%E8%A1%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:02 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:03 请求html错误 https://wn02.cc/search/?q=%E5%A5%B9%E7%9A%84%E5%AF%82%E5%AF%9E%E8%AA%B0%E4%BA%BA%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:03 请求html错误 https://wn02.cc/search/?q=%E7%96%AB%E6%83%85%E6%9C%9F%E9%96%93%E7%9A%84%E5%AE%B6%E6%95%99%E7%94%9F%E6%B4%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:03 请求html错误 https://wn02.cc/search/?q=%E5%A5%B3%E6%80%A7%E5%8F%8B%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:03 请求html错误 https://wn02.cc/search/index.php?q=%E5%A4%A7%E5%AD%B8%E7%94%9F%E6%B4%BB%E5%B0%B1%E5%BE%9E%E7%A4%BE%E5%9C%98%E9%96%8B%E5%A7%8B&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:00:03 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:04 请求html错误 https://wn02.cc/search/?q=%E7%A7%98%E5%AF%86%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:04 请求html错误 https://wn02.cc/search/index.php?q=%E5%82%80%E5%84%A1&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:00:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:04 请求html错误 https://wn02.cc/search/?q=%E7%99%A1%E6%BC%A2%E6%88%90%E7%99%AE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:04 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:05 请求html错误 https://wn02.cc/search/?q=%E5%85%B6%E5%AF%A6%E6%88%91%E5%BE%88%E5%96%9C%E6%AD%A1%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:05 请求html错误 https://wn02.cc/search/?q=%E9%87%8D%E9%80%A2%E7%9A%84%E5%88%9D%E6%88%80%E6%98%AF%E7%B9%BC%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:05 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:06 请求html错误 https://wn02.cc/search/?q=%E9%99%8C%E7%94%9F%E7%9A%84%E6%9C%AA%E5%A9%9A%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:06 请求html错误 https://wn02.cc/search/?q=%E6%85%BE%E6%B5%B7%E4%BA%A4%E9%8B%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:06 请求html错误 https://wn02.cc/search/?q=%E8%89%B2%E9%B5%B0%E8%8B%B1%E9%9B%84%E5%82%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:06 请求html错误 https://wn02.cc/search/?q=%E7%9B%A3%E7%8D%84%E5%A5%B3%E5%9B%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:06 请求html错误 https://wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E6%95%99%E6%8E%88%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:06 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:07 请求html错误 https://wn02.cc/search/?q=%E9%81%8A%E6%88%B2%E4%B8%8D%E8%83%BD%E9%80%99%E6%A8%A3%E7%8E%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:07 请求html错误 https://wn02.cc/search/?q=%E5%A4%B1%E6%86%B6%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:07 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%8D%80%E9%87%8D%E5%BB%BA%E5%8D%94%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:07 请求html错误 https://wn02.cc/search/?q=%E6%84%9B%E6%89%93%E9%81%8A%E6%88%B2%E7%9A%84%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:07 请求html错误 https://wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:07 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:08 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E7%94%A8%E5%95%AA%E6%94%AF%E4%BB%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:08 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E5%B1%85%E4%B8%8A%E4%B8%8B%E8%88%96&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:08 请求html错误 https://wn02.cc/search/?q=%E7%BE%8E%E9%BA%97%E6%96%B0%E4%B8%96%E7%95%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:08 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:09 请求html错误 https://wn02.cc/search/?q=%E8%B5%B0%E5%91%B3%E7%9A%84%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:09 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%A9%86%E8%87%B3%E4%B8%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:09 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E4%BA%8B%E7%89%A9%E8%AA%9E+Fantasy&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:09 请求html错误 https://wn02.cc/search/?q=%E4%B8%8D%E8%89%AF%E4%BA%8C%E7%AD%89%E5%85%B5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:09 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:10 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E5%AE%9A%E5%A4%A7%E9%98%AA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:10 请求html错误 https://wn02.cc/search/?q=%E6%B0%B4%E9%9B%BB%E5%B7%A5%E6%97%A5%E8%AA%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:10 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E7%9A%84%E9%A6%99%E5%91%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:10 请求html错误 https://wn02.cc/search/?q=%E5%A4%9C%E9%96%93%E8%A8%BA%E7%99%82%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:10 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E8%A4%B2%E8%A4%B2%E7%AD%86%E8%A8%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:10 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/?q=%E6%89%8B%E5%B7%A5%E9%A3%BE%E5%93%81%E5%B7%A5%E5%BB%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%AA%B2%E5%A4%96%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E5%AD%A9%E5%AD%90%E6%89%8D%E5%81%9A%E9%81%B8%E6%93%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/?q=%E6%83%A1%E5%A5%B3%E5%8B%BE%E5%8B%BE%E7%BA%8F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/index.php?q=%E9%98%BF%E5%A7%A8&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:11 请求html错误 https://wn02.cc/search/?q=%E9%A4%8A%E7%88%B6%E7%9A%84%E5%A5%B3%E5%85%92%E5%80%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:11 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:12 请求html错误 https://wn02.cc/search/?q=%E8%A1%97%E9%A0%AD%E5%B9%B9%E6%9E%B6%E7%8E%8B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:12 请求html错误 https://wn02.cc/search/?q=%E5%BE%A9%E4%BB%87%E6%AF%8D%E5%A5%B3%E4%B8%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:12 请求html错误 https://wn02.cc/search/?q=%E5%8F%8B%E6%83%85%E8%90%AC%E7%9D%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:12 请求html错误 https://wn02.cc/search/?q=%E6%90%B6%E5%A5%B3%E5%8F%8B%E9%80%9F%E6%88%90%E7%8F%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:12 请求html错误 https://wn02.cc/search/?q=%E6%AD%A1%E8%BF%8E%E5%8A%A0%E5%85%A5%E7%B2%89%E7%B5%B2%E5%9C%98%EF%BC%81+&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:12 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:13 请求html错误 https://wn02.cc/search/?q=%E9%9D%92%E6%A2%85%E4%BB%A5%E4%B8%8A%E6%88%80%E4%BA%BA%E6%9C%AA%E6%BB%BF&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:13 请求html错误 https://wn02.cc/search/?q=%E7%91%9C%E7%8F%88%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:13 请求html错误 https://wn02.cc/search/?q=%E5%88%86%E7%B5%84%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:13 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://wn02.cc/search/index.php?q=%E8%89%B2%E8%BC%AA%E7%9C%BC&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://wn02.cc/search/?q=%E7%98%8B%E4%BA%86%E6%89%8D%E7%B5%90%E5%A9%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://wn02.cc/search/?q=%E7%82%B8%E8%A3%82%E5%90%A7%21%E5%B7%A8%E6%A3%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://www.wn02.cc/search/?q=%E8%AA%BF%E6%95%99%E5%A6%BB%E5%AD%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://www.wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:14 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9B%E4%BA%BA%E5%90%8C%E5%B1%85%E5%A4%AA%E6%93%81%E6%93%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:14 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E4%BA%BA%E6%B0%A3%E7%BE%8E%E8%A1%93%E5%AE%B6%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E7%A5%9E%E7%A7%98%E9%A6%99%E5%91%B3%E7%A0%94%E7%A9%B6%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E7%9B%B4%E6%92%AD%E4%B8%BB%E7%9A%84%E6%B5%81%E9%87%8F%E5%AF%86%E7%A2%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E5%82%B3%E5%AE%97%E6%8E%A5%E4%BB%A3%E5%A5%BD%E5%9B%B0%E9%9B%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E9%82%82%E9%80%85&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:15 请求html错误 https://www.wn02.cc/search/?q=%E7%86%9F%E5%A5%B3%E9%83%BD%E6%84%9B%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:15 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%8C%E7%BE%8E%E5%A6%BB%E5%AD%90%E7%9A%84%E8%83%8C%E5%8F%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://wn02.cc/search/?q=%E8%AE%93%E4%BA%BA%E7%81%AB%E5%A4%A7%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E6%8A%8A%E5%A5%B3%E5%85%92%E4%BA%A4%E7%B5%A6%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://wn02.cc/search/?q=%E6%82%A3%E5%BE%97%E6%82%A3%E5%A4%B1%E7%9A%84%E6%84%9B%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:16 请求html错误 https://wn02.cc/search/?q=%E7%9B%B8%E8%A6%AA%E7%9B%B8%E6%84%9B%E4%B8%80%E5%AE%B6%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:16 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:17 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E7%9A%84%E6%80%A7%E7%A6%8F%E5%8A%87%E6%9C%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:17 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E8%88%87%E7%B9%BC%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:17 请求html错误 https://wn02.cc/search/?q=%E7%A9%BF%E5%85%A5VR%E6%88%90%E7%82%BA%E6%80%A7%E5%9F%9F%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:17 请求html错误 https://wn02.cc/search/?q=%E6%83%B3%E8%A6%81%E6%93%81%E6%9C%89%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:17 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:17 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:18 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E5%A3%AB%E5%85%B5%E7%9A%84%E9%9B%8C%E6%80%A7%E5%BE%81%E6%9C%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:18 请求html错误 https://www.wn02.cc/search/?q=%E5%AD%B8%E6%A0%A1%E6%AF%8D%E6%B9%AF%E9%BB%91%E7%99%BD%E4%BE%86%EF%BC%81&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:18 请求html错误 https://www.wn02.cc/search/?q=%E8%AE%93%E5%82%B2%E6%85%A2%E5%A5%B3%E5%B1%88%E6%9C%8D%E7%9A%84%E4%B8%80%E7%99%BE%E7%A8%AE%E6%96%B9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:18 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:18 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%BD%E9%81%8B%E8%A8%88%E7%A8%8B%E8%BB%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:19 请求html错误 https://www.wn02.cc/search/?q=%E7%84%A1%E6%B3%95%E5%85%8B%E5%88%B6%E7%9A%84%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:19 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:19 请求html错误 https://www.wn02.cc/search/?q=%E5%BC%B7%E5%88%B6%E5%82%AC%E7%9C%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:19 请求html错误 https://www.wn02.cc/search/?q=%E9%9F%B6%E6%81%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:19 请求html错误 https://www.wn02.cc/search/?q=%E6%8E%A0%E5%A5%AA%E8%A1%8C%E5%8B%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:20 请求html错误 https://www.wn02.cc/search/?q=%E7%99%A2%E6%A8%82%E5%A4%9A%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:20 请求html错误 https://www.wn02.cc/search/?q=%E8%B1%AA%E8%89%B2%E5%BE%A9%E4%BB%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:20 请求html错误 https://www.wn02.cc/search/?q=%E6%85%BE%E6%9C%9B%E9%81%8A%E6%88%B2%E5%AF%A6%E5%A2%83%E7%A7%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:20 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%B5%84%E5%AE%B6%E5%BA%AD%E5%A5%BD%E5%B0%B7%E5%B0%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:20 请求html错误 https://www.wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E8%A6%AA%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:21 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8B%E7%8F%AD%E5%BE%8C%E7%9A%84%E7%A7%98%E5%AF%86%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:21 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E5%BE%AE%E5%A6%99%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:21 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A6%81%E6%AC%BA%E8%B2%A0%E6%88%91%E5%A7%90%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:21 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A9%B2%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:21 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E9%97%86%E5%A8%98%E7%9A%84%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:22 请求html错误 https://www.wn02.cc/search/?q=%E6%80%A7%E9%81%8B%E5%88%AE%E5%88%AE%E6%A8%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:22 请求html错误 https://www.wn02.cc/search/?q=%E5%A3%9E%E5%A5%B3%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:22 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%80%E6%A1%BF%E9%80%B2%E6%B4%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:23 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E6%8E%A7&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:23 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E4%BA%BA%E9%BA%A5%E8%A8%88%E8%BC%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:23 请求html错误 https://www.wn02.cc/search/?q=%E9%84%B0%E5%B1%85%E8%B7%91%E8%B7%AF%E4%B8%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:23 请求html错误 https://www.wn02.cc/search/?q=%E5%86%B0%E5%B1%B1%E4%B8%BB%E7%AE%A1%E7%9A%84%E7%A7%98%E5%AF%86%E8%88%88%E8%B6%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:23 请求html错误 https://www.wn02.cc/search/?q=%E4%BC%BC%E6%9B%BE%E7%9B%B8%E8%AD%98%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E6%84%8F%E5%A4%96%E7%9A%84%E7%A7%81%E5%AF%86%E7%89%BD%E7%B5%86&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E5%A9%9A%E5%A7%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E5%BF%AB%E6%A8%82%E4%B9%8B%E7%A5%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E6%95%99%E4%BD%8F%E6%88%91%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%A8%E7%A7%80%E8%88%87%E5%8D%9E%E6%B3%B0%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:24 请求html错误 https://www.wn02.cc/search/?q=%E6%95%99%E8%A8%93%E5%91%8A%E7%99%BD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:25 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%8B%E6%89%BE%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:25 请求html错误 https://www.wn02.cc/search/?q=%E5%92%96%E5%95%A1%E5%9B%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:25 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:25 请求html错误 https://www.wn02.cc/search/?q=%E8%BF%94%E9%84%89%E5%BE%8C%E7%9A%84%E6%98%A5%E5%A4%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:25 请求html错误 https://www.wn02.cc/search/?q=%E6%AF%92%E9%85%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:26 请求html错误 https://www.wn02.cc/search/?q=%E9%81%8A%E6%A8%82%E5%9C%92%E7%94%B7%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:26 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%A6%AA%E5%AF%86%E6%8C%87%E5%B0%8E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:26 请求html错误 https://www.wn02.cc/search/?q=%E8%8A%B1%E5%AE%B9%E6%BF%95%E8%89%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:26 请求html错误 https://www.wn02.cc/search/?q=%E5%82%AC%E7%9C%A0%E6%92%A9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:26 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E7%B4%9A%E9%8A%80%E8%A1%8C%E6%A5%AD%E5%8B%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:27 请求html错误 https://www.wn02.cc/search/?q=%E8%84%AB%E5%BA%8F%E4%BA%BA%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:27 请求html错误 https://www.wn02.cc/search/?q=%E6%94%BE%E4%BB%BB%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:27 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E6%88%90%E7%82%BA%E5%A4%A7%E9%9A%BB%E4%BD%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:27 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:27 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%BB%E8%A9%A6%E4%B9%8B%E7%A5%9E%E5%AD%B8%E7%BF%92%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:28 请求html错误 https://www.wn02.cc/search/?q=%E4%BB%96%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:28 请求html错误 https://www.wn02.cc/search/?q=%E6%96%B0%E9%83%BD%E5%B8%82%E5%A4%96%E9%80%81%E5%93%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:28 请求html错误 https://www.wn02.cc/albums-index-page-6-cate-20.html
2024/10/24 16:00:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:28 请求html错误 https://www.wn02.cc/search/?q=%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%81%B7%E5%81%B7%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:28 请求html错误 https://www.wn02.cc/search/?q=%E5%AB%81%E5%85%A5%E8%B1%AA%E9%96%80%E7%9A%84%E8%80%81%E5%B8%AB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:29 请求html错误 https://www.wn02.cc/search/?q=%E7%8B%82%E7%9C%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:29 请求html错误 https://www.wn02.cc/search/?q=Set+up%21%E6%8E%92%E7%90%83%E5%B0%91%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:29 请求html错误 https://www.wn02.cc/search/?q=%E5%B2%B3%E6%AF%8D%E7%82%BA%E4%BD%95%E9%82%A3%E6%A8%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:29 请求html错误 https://www.wn02.cc/search/?q=%E5%85%84%E5%A6%B9%E7%9A%84%E7%A7%98%E5%AF%86%E6%8E%88%E8%AA%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:29 请求html错误 https://www.wn02.cc/search/?q=%E7%B3%96%E6%9E%9C%E7%88%B8%E7%88%B8%E7%9A%84%E6%90%B6%E5%A9%9A%E5%A4%A7%E4%BD%9C%E6%88%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:30 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:30 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:30 请求html错误 https://www.wn02.cc/search/?q=%E5%81%B6%E7%84%B6%E7%99%BC%E7%8F%BE%E6%88%91%E6%84%9B%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:30 请求html错误 https://www.wn02.cc/search/?q=%E5%A4%A9%E4%B8%8A%E6%8E%89%E4%B8%8B%E4%BE%86%E7%9A%84%E7%88%BD%E7%BC%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%88%BD%E7%88%BD%E5%8D%87%E7%B4%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E5%90%8C%E5%AD%B8%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%B9%E6%89%8D%E4%B8%8D%E6%98%AF%E6%88%91%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%9A%84%E5%95%A6%E5%95%A6%E9%9A%8A%E7%BE%8E%E7%9C%89&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E5%81%8F%E5%81%8F%E6%85%BE%E5%88%B0%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:31 请求html错误 https://www.wn02.cc/search/?q=%E5%B9%BC%E9%BD%92%E5%B0%8F%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:32 请求html错误 https://www.wn02.cc/search/?q=%E7%94%9C%E8%9C%9C%E7%9A%84%E5%81%87%E6%9C%9F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:32 请求html错误 https://www.wn02.cc/search/?q=%E5%91%BD%E9%81%8B%3A%E8%B2%9E%E6%BD%94%E6%85%BE%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:00:32 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E5%88%B0%E9%81%8E%E5%8E%BB%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:00:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:18 请求html错误 https://wn02.cc/search/?q=%E5%88%9D%E6%AC%A1%E6%B7%B1%E4%BA%A4%EF%BC%8C%E8%AB%8B%E5%A4%9A%E6%8C%87%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:18 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:19 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%9C%98%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:19 请求html错误 https://wn02.cc/search/?q=%E6%B4%9E%E6%B4%9E%E9%9B%9C%E8%B2%A8%E5%BA%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:19 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:20 请求html错误 https://wn02.cc/search/?q=%E6%95%99%E7%BE%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:20 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E5%AE%B6%E7%9A%84%E8%B4%85%E5%A9%BF%E5%A4%A7%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:20 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:21 请求html错误 https://wn02.cc/search/?q=%E6%88%80%E6%84%9B%E4%BF%A1%E4%BB%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:21 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E9%AB%94%E5%85%A7%E7%9A%84%E9%82%A3%E5%80%8B%E7%A5%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:21 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E4%BA%8B%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:21 请求html错误 https://wn02.cc/search/?q=%E8%B7%91%E5%8F%8B%E8%AE%8A%E5%B2%B3%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:21 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:22 请求html错误 https://wn02.cc/search/?q=%E7%A6%81%E9%8C%AE%E4%B9%8B%E6%85%BE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:22 请求html错误 https://wn02.cc/search/?q=%E8%90%AC%E8%83%BD%E5%B1%A5%E6%AD%B7%E8%A1%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:22 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:23 请求html错误 https://wn02.cc/search/?q=%E5%A5%B9%E7%9A%84%E5%AF%82%E5%AF%9E%E8%AA%B0%E4%BA%BA%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:23 请求html错误 https://wn02.cc/search/?q=%E7%96%AB%E6%83%85%E6%9C%9F%E9%96%93%E7%9A%84%E5%AE%B6%E6%95%99%E7%94%9F%E6%B4%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:23 请求html错误 https://wn02.cc/search/?q=%E5%A5%B3%E6%80%A7%E5%8F%8B%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:23 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:24 请求html错误 https://wn02.cc/search/index.php?q=%E5%A4%A7%E5%AD%B8%E7%94%9F%E6%B4%BB%E5%B0%B1%E5%BE%9E%E7%A4%BE%E5%9C%98%E9%96%8B%E5%A7%8B&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:06:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:24 请求html错误 https://wn02.cc/search/?q=%E7%A7%98%E5%AF%86%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:24 请求html错误 https://wn02.cc/search/index.php?q=%E5%82%80%E5%84%A1&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:06:24 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:25 请求html错误 https://wn02.cc/search/?q=%E7%99%A1%E6%BC%A2%E6%88%90%E7%99%AE&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:25 请求html错误 https://wn02.cc/search/?q=%E5%85%B6%E5%AF%A6%E6%88%91%E5%BE%88%E5%96%9C%E6%AD%A1%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:25 请求html错误 https://wn02.cc/search/?q=%E9%87%8D%E9%80%A2%E7%9A%84%E5%88%9D%E6%88%80%E6%98%AF%E7%B9%BC%E6%AF%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:25 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:26 请求html错误 https://wn02.cc/search/?q=%E9%99%8C%E7%94%9F%E7%9A%84%E6%9C%AA%E5%A9%9A%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:26 请求html错误 https://wn02.cc/search/?q=%E6%85%BE%E6%B5%B7%E4%BA%A4%E9%8B%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:26 请求html错误 https://wn02.cc/search/?q=%E8%89%B2%E9%B5%B0%E8%8B%B1%E9%9B%84%E5%82%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:26 请求html错误 https://wn02.cc/search/?q=%E7%9B%A3%E7%8D%84%E5%A5%B3%E5%9B%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:26 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:27 请求html错误 https://wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E6%95%99%E6%8E%88%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:27 请求html错误 https://wn02.cc/search/?q=%E9%81%8A%E6%88%B2%E4%B8%8D%E8%83%BD%E9%80%99%E6%A8%A3%E7%8E%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:27 请求html错误 https://wn02.cc/search/?q=%E5%A4%B1%E6%86%B6%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:27 请求html错误 https://wn02.cc/search/?q=%E7%A4%BE%E5%8D%80%E9%87%8D%E5%BB%BA%E5%8D%94%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:27 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:28 请求html错误 https://wn02.cc/search/?q=%E6%84%9B%E6%89%93%E9%81%8A%E6%88%B2%E7%9A%84%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:28 请求html错误 https://wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:28 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E7%94%A8%E5%95%AA%E6%94%AF%E4%BB%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:28 请求html错误 https://wn02.cc/search/?q=%E5%90%8C%E5%B1%85%E4%B8%8A%E4%B8%8B%E8%88%96&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:28 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:29 请求html错误 https://wn02.cc/search/?q=%E7%BE%8E%E9%BA%97%E6%96%B0%E4%B8%96%E7%95%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:29 请求html错误 https://wn02.cc/search/?q=%E8%B5%B0%E5%91%B3%E7%9A%84%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:29 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%A9%86%E8%87%B3%E4%B8%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:29 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E4%BA%8B%E7%89%A9%E8%AA%9E+Fantasy&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:29 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:30 请求html错误 https://wn02.cc/search/?q=%E4%B8%8D%E8%89%AF%E4%BA%8C%E7%AD%89%E5%85%B5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:30 请求html错误 https://wn02.cc/search/?q=%E6%83%85%E5%AE%9A%E5%A4%A7%E9%98%AA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:30 请求html错误 https://wn02.cc/search/?q=%E6%B0%B4%E9%9B%BB%E5%B7%A5%E6%97%A5%E8%AA%8C&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:30 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E7%9A%84%E9%A6%99%E5%91%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:30 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:31 请求html错误 https://wn02.cc/search/?q=%E5%A4%9C%E9%96%93%E8%A8%BA%E7%99%82%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:31 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E8%A4%B2%E8%A4%B2%E7%AD%86%E8%A8%98&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:31 请求html错误 https://wn02.cc/search/?q=%E6%89%8B%E5%B7%A5%E9%A3%BE%E5%93%81%E5%B7%A5%E5%BB%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:31 请求html错误 https://wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%AA%B2%E5%A4%96%E6%95%99%E5%AD%B8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:31 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:32 请求html错误 https://wn02.cc/search/?q=%E5%B0%8F%E5%AD%A9%E5%AD%90%E6%89%8D%E5%81%9A%E9%81%B8%E6%93%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:32 请求html错误 https://wn02.cc/search/?q=%E6%83%A1%E5%A5%B3%E5%8B%BE%E5%8B%BE%E7%BA%8F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:32 请求html错误 https://wn02.cc/search/index.php?q=%E9%98%BF%E5%A7%A8&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:06:32 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E9%A4%8A%E7%88%B6%E7%9A%84%E5%A5%B3%E5%85%92%E5%80%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E8%A1%97%E9%A0%AD%E5%B9%B9%E6%9E%B6%E7%8E%8B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E5%BE%A9%E4%BB%87%E6%AF%8D%E5%A5%B3%E4%B8%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E5%8F%8B%E6%83%85%E8%90%AC%E7%9D%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E6%90%B6%E5%A5%B3%E5%8F%8B%E9%80%9F%E6%88%90%E7%8F%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:33 请求html错误 https://wn02.cc/search/?q=%E6%AD%A1%E8%BF%8E%E5%8A%A0%E5%85%A5%E7%B2%89%E7%B5%B2%E5%9C%98%EF%BC%81+&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:33 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:34 请求html错误 https://wn02.cc/search/?q=%E9%9D%92%E6%A2%85%E4%BB%A5%E4%B8%8A%E6%88%80%E4%BA%BA%E6%9C%AA%E6%BB%BF&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:34 请求html错误 https://wn02.cc/search/?q=%E7%91%9C%E7%8F%88%E5%88%9D%E9%AB%94%E9%A9%97&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:34 请求html错误 https://wn02.cc/search/?q=%E5%88%86%E7%B5%84%E6%8F%9B%E6%8F%9B%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:34 请求html错误 https://wn02.cc/search/index.php?q=%E8%89%B2%E8%BC%AA%E7%9C%BC&m=&syn=yes&f=_all&s=create_time_DESC&p=1
2024/10/24 16:06:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:34 请求html错误 https://wn02.cc/search/?q=%E7%98%8B%E4%BA%86%E6%89%8D%E7%B5%90%E5%A9%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:34 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:35 请求html错误 https://wn02.cc/search/?q=%E7%82%B8%E8%A3%82%E5%90%A7%21%E5%B7%A8%E6%A3%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:35 请求html错误 https://www.wn02.cc/search/?q=%E8%AA%BF%E6%95%99%E5%A6%BB%E5%AD%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:35 请求html错误 https://www.wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:35 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9B%E4%BA%BA%E5%90%8C%E5%B1%85%E5%A4%AA%E6%93%81%E6%93%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:35 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E4%BA%BA%E6%B0%A3%E7%BE%8E%E8%A1%93%E5%AE%B6%E6%95%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:35 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E7%A5%9E%E7%A7%98%E9%A6%99%E5%91%B3%E7%A0%94%E7%A9%B6%E5%AE%A4&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E7%9B%B4%E6%92%AD%E4%B8%BB%E7%9A%84%E6%B5%81%E9%87%8F%E5%AF%86%E7%A2%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E5%82%B3%E5%AE%97%E6%8E%A5%E4%BB%A3%E5%A5%BD%E5%9B%B0%E9%9B%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E9%82%82%E9%80%85&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E7%86%9F%E5%A5%B3%E9%83%BD%E6%84%9B%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:36 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%8C%E7%BE%8E%E5%A6%BB%E5%AD%90%E7%9A%84%E8%83%8C%E5%8F%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:36 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:37 请求html错误 https://wn02.cc/search/?q=%E8%AE%93%E4%BA%BA%E7%81%AB%E5%A4%A7%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:37 请求html错误 https://wn02.cc/search/?q=%E8%AB%8B%E6%8A%8A%E5%A5%B3%E5%85%92%E4%BA%A4%E7%B5%A6%E6%88%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:37 请求html错误 https://wn02.cc/search/?q=%E6%82%A3%E5%BE%97%E6%82%A3%E5%A4%B1%E7%9A%84%E6%84%9B%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:37 请求html错误 https://wn02.cc/search/?q=%E8%8F%9C%E9%B3%A5%E6%95%99%E7%B7%B4%E7%9A%84%E9%80%86%E8%A5%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:37 请求html错误 https://wn02.cc/search/?q=%E7%9B%B8%E8%A6%AA%E7%9B%B8%E6%84%9B%E4%B8%80%E5%AE%B6%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:37 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:38 请求html错误 https://wn02.cc/search/?q=%E6%88%91%E7%9A%84%E6%80%A7%E7%A6%8F%E5%8A%87%E6%9C%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:38 请求html错误 https://wn02.cc/search/?q=%E7%B9%BC%E6%AF%8D%E8%88%87%E7%B9%BC%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:38 请求html错误 https://wn02.cc/search/?q=%E7%A9%BF%E5%85%A5VR%E6%88%90%E7%82%BA%E6%80%A7%E5%9F%9F%E7%8D%B5%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:38 请求html错误 https://wn02.cc/search/?q=%E6%83%B3%E8%A6%81%E6%93%81%E6%9C%89%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:38 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:38 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E5%A3%AB%E5%85%B5%E7%9A%84%E9%9B%8C%E6%80%A7%E5%BE%81%E6%9C%8D&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E5%AD%B8%E6%A0%A1%E6%AF%8D%E6%B9%AF%E9%BB%91%E7%99%BD%E4%BE%86%EF%BC%81&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E8%AE%93%E5%82%B2%E6%85%A2%E5%A5%B3%E5%B1%88%E6%9C%8D%E7%9A%84%E4%B8%80%E7%99%BE%E7%A8%AE%E6%96%B9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%BD%E9%81%8B%E8%A8%88%E7%A8%8B%E8%BB%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:39 请求html错误 https://www.wn02.cc/search/?q=%E7%84%A1%E6%B3%95%E5%85%8B%E5%88%B6%E7%9A%84%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:39 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:40 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:40 请求html错误 https://www.wn02.cc/search/?q=%E5%BC%B7%E5%88%B6%E5%82%AC%E7%9C%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:40 请求html错误 https://www.wn02.cc/search/?q=%E9%9F%B6%E6%81%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:40 请求html错误 https://www.wn02.cc/search/?q=%E6%8E%A0%E5%A5%AA%E8%A1%8C%E5%8B%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:40 请求html错误 https://www.wn02.cc/search/?q=%E7%99%A2%E6%A8%82%E5%A4%9A%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:40 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:41 请求html错误 https://www.wn02.cc/search/?q=%E8%B1%AA%E8%89%B2%E5%BE%A9%E4%BB%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:41 请求html错误 https://www.wn02.cc/search/?q=%E6%85%BE%E6%9C%9B%E9%81%8A%E6%88%B2%E5%AF%A6%E5%A2%83%E7%A7%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:41 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%B5%84%E5%AE%B6%E5%BA%AD%E5%A5%BD%E5%B0%B7%E5%B0%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:41 请求html错误 https://www.wn02.cc/search/?q=%E5%AF%84%E7%94%9F%E8%A6%AA%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:41 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8B%E7%8F%AD%E5%BE%8C%E7%9A%84%E7%A7%98%E5%AF%86%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:41 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E5%BE%AE%E5%A6%99%E9%97%9C%E4%BF%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A6%81%E6%AC%BA%E8%B2%A0%E6%88%91%E5%A7%90%E5%A7%90&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E8%A9%B2%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E9%97%86%E5%A8%98%E7%9A%84%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E6%80%A7%E9%81%8B%E5%88%AE%E5%88%AE%E6%A8%82&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:42 请求html错误 https://www.wn02.cc/search/?q=%E5%A3%9E%E5%A5%B3%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:42 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:43 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%80%E6%A1%BF%E9%80%B2%E6%B4%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:43 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%BA%E5%A6%BB%E6%8E%A7&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:43 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E4%BA%BA%E9%BA%A5%E8%A8%88%E8%BC%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:43 请求html错误 https://www.wn02.cc/search/?q=%E9%84%B0%E5%B1%85%E8%B7%91%E8%B7%AF%E4%B8%AD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:43 请求html错误 https://www.wn02.cc/search/?q=%E5%86%B0%E5%B1%B1%E4%B8%BB%E7%AE%A1%E7%9A%84%E7%A7%98%E5%AF%86%E8%88%88%E8%B6%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:43 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:44 请求html错误 https://www.wn02.cc/search/?q=%E4%BC%BC%E6%9B%BE%E7%9B%B8%E8%AD%98%E7%9A%84%E5%A5%B9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:44 请求html错误 https://www.wn02.cc/search/?q=%E6%84%8F%E5%A4%96%E7%9A%84%E7%A7%81%E5%AF%86%E7%89%BD%E7%B5%86&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:44 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E4%B8%8D%E5%8E%BB%E7%9A%84%E5%A9%9A%E5%A7%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:44 请求html错误 https://www.wn02.cc/search/?q=%E5%BF%AB%E6%A8%82%E4%B9%8B%E7%A5%9E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:44 请求html错误 https://www.wn02.cc/search/?q=%E5%AE%B6%E6%95%99%E4%BD%8F%E6%88%91%E5%AE%B6&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:44 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:45 请求html错误 https://www.wn02.cc/search/?q=%E4%BA%A8%E7%A7%80%E8%88%87%E5%8D%9E%E6%B3%B0%E7%9F%A5&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:45 请求html错误 https://www.wn02.cc/search/?q=%E6%95%99%E8%A8%93%E5%91%8A%E7%99%BD&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:45 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%8B%E6%89%BE%E5%88%9D%E6%88%80&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:45 请求html错误 https://www.wn02.cc/search/?q=%E5%92%96%E5%95%A1%E5%9B%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:45 请求html错误 https://www.wn02.cc/search/?q=%E4%B8%8D%E6%83%B3%E5%86%8D%E7%95%B6%E9%AD%AF%E8%9B%87&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:45 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:46 请求html错误 https://www.wn02.cc/search/?q=%E8%BF%94%E9%84%89%E5%BE%8C%E7%9A%84%E6%98%A5%E5%A4%A9&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:46 请求html错误 https://www.wn02.cc/search/?q=%E6%AF%92%E9%85%92&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:46 请求html错误 https://www.wn02.cc/search/?q=%E9%81%8A%E6%A8%82%E5%9C%92%E7%94%B7%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:46 请求html错误 https://www.wn02.cc/search/?q=%E8%80%81%E5%B8%AB%E7%9A%84%E8%A6%AA%E5%AF%86%E6%8C%87%E5%B0%8E&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:46 请求html错误 https://www.wn02.cc/search/?q=%E8%8A%B1%E5%AE%B9%E6%BF%95%E8%89%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:46 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:47 请求html错误 https://www.wn02.cc/search/?q=%E5%82%AC%E7%9C%A0%E6%92%A9%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:47 请求html错误 https://www.wn02.cc/search/?q=%E8%B6%85%E7%B4%9A%E9%8A%80%E8%A1%8C%E6%A5%AD%E5%8B%99&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:47 请求html错误 https://www.wn02.cc/search/?q=%E8%84%AB%E5%BA%8F%E4%BA%BA%E5%A6%BB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:47 请求html错误 https://www.wn02.cc/search/?q=%E6%94%BE%E4%BB%BB%E8%AA%98%E6%83%91&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:47 请求html错误 https://www.wn02.cc/search/?q=%E9%87%8D%E7%94%9F%E6%88%90%E7%82%BA%E5%A4%A7%E9%9A%BB%E4%BD%AC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:47 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:48 请求html错误 https://www.wn02.cc/search/?q=%E9%9B%99%E9%9D%A2%E4%BA%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:48 请求html错误 https://www.wn02.cc/search/?q=%E5%B0%BB%E8%A9%A6%E4%B9%8B%E7%A5%9E%E5%AD%B8%E7%BF%92%E6%B3%95&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:48 请求html错误 https://www.wn02.cc/search/?q=%E4%BB%96%E7%9A%84%E8%B6%85%E8%83%BD%E5%8A%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:48 请求html错误 https://www.wn02.cc/search/?q=%E6%96%B0%E9%83%BD%E5%B8%82%E5%A4%96%E9%80%81%E5%93%A1&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:48 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/albums-index-page-6-cate-20.html
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/search/?q=%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%81%B7%E5%81%B7%E6%84%9B&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/search/?q=%E5%AB%81%E5%85%A5%E8%B1%AA%E9%96%80%E7%9A%84%E8%80%81%E5%B8%AB&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/search/?q=%E7%8B%82%E7%9C%BC&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/search/?q=Set+up%21%E6%8E%92%E7%90%83%E5%B0%91%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:49 请求html错误 https://www.wn02.cc/search/?q=%E5%B2%B3%E6%AF%8D%E7%82%BA%E4%BD%95%E9%82%A3%E6%A8%A3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:49 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:50 请求html错误 https://www.wn02.cc/search/?q=%E5%85%84%E5%A6%B9%E7%9A%84%E7%A7%98%E5%AF%86%E6%8E%88%E8%AA%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:50 请求html错误 https://www.wn02.cc/search/?q=%E7%B3%96%E6%9E%9C%E7%88%B8%E7%88%B8%E7%9A%84%E6%90%B6%E5%A9%9A%E5%A4%A7%E4%BD%9C%E6%88%B0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:50 请求html错误 https://www.wn02.cc/search/?q=%E7%8E%A9%E8%BD%89%E5%AD%B8%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:50 请求html错误 https://www.wn02.cc/search/?q=RE%EF%BC%9A23%E6%AD%B2&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:50 请求html错误 https://www.wn02.cc/search/?q=%E5%81%B6%E7%84%B6%E7%99%BC%E7%8F%BE%E6%88%91%E6%84%9B%E4%BD%A0&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:50 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:51 请求html错误 https://www.wn02.cc/search/?q=%E5%A4%A9%E4%B8%8A%E6%8E%89%E4%B8%8B%E4%BE%86%E7%9A%84%E7%88%BD%E7%BC%BA&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:51 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:51 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%88%BD%E7%88%BD%E5%8D%87%E7%B4%9A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:51 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:51 请求html错误 https://www.wn02.cc/search/?q=%E5%8D%B1%E9%9A%AA%E5%90%8C%E5%AD%B8%E6%9C%83&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:51 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:51 请求html错误 https://www.wn02.cc/search/?q=%E5%A5%B9%E6%89%8D%E4%B8%8D%E6%98%AF%E6%88%91%E5%A7%8A%E5%A7%8A&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:51 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:51 请求html错误 https://www.wn02.cc/search/?q=%E6%88%91%E7%9A%84%E5%95%A6%E5%95%A6%E9%9A%8A%E7%BE%8E%E7%9C%89&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:51 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:52 请求html错误 https://www.wn02.cc/search/?q=%E5%81%8F%E5%81%8F%E6%85%BE%E5%88%B0%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:52 请求html错误 https://www.wn02.cc/search/?q=%E5%B9%BC%E9%BD%92%E5%B0%8F%E9%98%BF%E5%A7%A8&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:52 请求html错误 https://www.wn02.cc/search/?q=%E7%94%9C%E8%9C%9C%E7%9A%84%E5%81%87%E6%9C%9F&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:52 请求html错误 https://www.wn02.cc/search/?q=%E5%91%BD%E9%81%8B%3A%E8%B2%9E%E6%BD%94%E6%85%BE%E5%A5%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:52 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:06:53 请求html错误 https://www.wn02.cc/search/?q=%E5%9B%9E%E5%88%B0%E9%81%8E%E5%8E%BB%E6%84%9B%E4%B8%8A%E5%A6%B3&f=_all&s=create_time_DESC&syn=yes
2024/10/24 16:06:53 System.Net.WebException: 基础连接已经关闭: 发送时发生错误。 ---> System.IO.IOException: 无法从传输连接中读取数据: 远程主机强迫关闭了一个现有的连接。。 ---> System.Net.Sockets.SocketException: 远程主机强迫关闭了一个现有的连接。
   在 System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.Sockets.NetworkStream.Read(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.FixedSizeReader.ReadPacket(Byte[] buffer, Int32 offset, Int32 count)
   在 System.Net.Security.SslState.StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)
   在 System.Net.Security.SslState.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ForceAuthentication(Boolean receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest, Boolean renegotiation)
   在 System.Net.Security.SslState.ProcessAuthentication(LazyAsyncResult lazyResult)
   在 System.Net.TlsStream.CallProcessAuthentication(Object state)
   在 System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   在 System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   在 System.Net.TlsStream.ProcessAuthentication(LazyAsyncResult result)
   在 System.Net.TlsStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.PooledStream.Write(Byte[] buffer, Int32 offset, Int32 size)
   在 System.Net.ConnectStream.WriteHeaders(Boolean async)
   --- 内部异常堆栈跟踪的结尾 ---
   在 System.Net.HttpWebRequest.GetResponse()
   在 manga_reptile.analysis.get_html_by_request(String url, String cookie, String referer) 位置 C:\Program-User\10temp\00github\manga-reptile\manga-reptile\class\derive\analysis.cs:行号 246
2024/10/24 16:28:10 下载章节 大學生活就從社團開始65-66話, 共21张图片.
2024/10/24 16:28:53 下载章节 大學生活就從社團開始63-64話, 共23张图片.
2024/10/24 16:30:05 下载章节 大學生活就從社團開始61-62話, 共22张图片.
2024/10/24 16:31:07 下载章节 大學生活就從社團開始59-60話, 共22张图片.
2024/10/24 16:31:39 下载章节 大學生活就從社團開始57-58話, 共25张图片.
2024/10/24 16:32:18 下载章节 大學生活就從社團開始55-56話, 共23张图片.
2024/10/24 16:32:51 下载章节 大學生活就從社團開始53-54話, 共22张图片.
2024/10/24 16:33:36 下载章节 大學生活就從社團開始51-52話, 共21张图片.
2024/10/24 16:34:14 下载章节 大學生活就從社團開始49-50話, 共21张图片.
2024/10/24 16:34:51 下载章节 大學生活就從社團開始47-48話, 共22张图片.
2024/10/24 16:35:32 下载章节 大學生活就從社團開始45-46話, 共22张图片.
2024/10/24 16:36:25 下载章节 大學生活就從社團開始43-44話, 共21张图片.
2024/10/24 16:37:13 下载章节 大學生活就從社團開始41-42話, 共23张图片.
2024/10/24 16:37:48 下载章节 大學生活就從社團開始39-40話, 共23张图片.
2024/10/24 16:38:27 下载章节 大學生活就從社團開始37-38話, 共25张图片.
2024/10/24 16:39:02 下载章节 大學生活就從社團開始35-36話, 共26张图片.
2024/10/24 16:39:33 下载章节 大學生活就從社團開始33-34話, 共22张图片.
2024/10/24 16:40:17 下载章节 大學生活就從社團開始31-32話, 共22张图片.
2024/10/24 16:41:04 下载章节 大學生活就從社團開始29-30話, 共23张图片.
2024/10/24 16:41:36 下载章节 大學生活就從社團開始27-28話, 共23张图片.
2024/10/24 16:42:38 下载章节 大學生活就從社團開始25-26話, 共34张图片.
2024/10/24 16:43:38 下载章节 大學生活就從社團開始23-24話, 共33张图片.
2024/10/24 16:44:45 下载章节 大學生活就從社團開始21-22話, 共38张图片.
2024/10/24 16:45:48 下载章节 大學生活就從社團開始19-20話, 共45张图片.
2024/10/24 16:47:04 下载章节 大學生活就從社團開始17-18話, 共40张图片.
2024/10/24 16:48:06 下载章节 大學生活就從社團開始15-16話, 共54张图片.
2024/10/24 16:49:09 下载章节 大學生活就從社團開始13-14話, 共51张图片.
2024/10/24 16:50:35 下载章节 大學生活就從社團開始11-12話, 共54张图片.
2024/10/24 16:51:34 下载章节 大學生活就從社團開始9-10話, 共54张图片.
2024/10/24 16:52:26 下载章节 大學生活就從社團開始7-8話, 共55张图片.
2024/10/24 16:53:28 下载章节 大學生活就從社團開始5-6話, 共54张图片.
2024/10/24 16:55:41 下载章节 大學生活就從社團開始1-4話, 共117张图片.
